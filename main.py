#!miniconda3/envs/virtualEnv/bin/python

"""
Author: (NIWANTHA MEEPAGE) 
EDITED v1.9.3  :   7Th Jan 2022  [PROCESS TX RX ]
Descriptions: [RFC6910]
MAJOR RELEASE   :   v1.9.3
!<-------------------------------->!
SIP :RFC
1)  RFC1889 - RTP & QoS
2)  RFC2325 - RTPSP (Controlling)
3)  RFC3015 - Media Gateway Control Protocol (For PSTN)
4)  RFC2327 - Session Description Protocol (SDP)
5)  RFC3261 - Header Details ############### https://datatracker.ietf.org/doc/html/rfc3261#section-20

SIP URI: (HTTP-like request/response transaction model)
        sip:user@host_name


        Via:    contains the address of #local_host# at which "ANY" is
                expecting to receive responses to this request.  It also contains a
                branch parameter that identifies this transaction

    (a)    INVITE sip:TO_EXT@REMOTE_SERVER;user=phone;transport=UDP;tgrp=1;trunk-context=mitel.test.com SIP/2.0\r\n"

    (b)    Via: SIP/2.0/UDP LOCAL_SERVER:5060;branch=z9hG4bK-{}\r\n


                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                quoted-pair     =       ("\" text) / obs-qp

                Where any quoted-pair appears, it is to be interpreted as the text
                character alone.  That is to say, the "\" character that appears as
                part of a quoted-pair is semantically "invisible".
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        To:     contains a display name (#In this only ext  number#) and a SIP or SIPS URI
                (sip:name/number@remote SIP_SERVER) towards which the request was originally
                directed.  Display names are described in RFC 2822

        From:   also contains a display name (#here will use Caller's ext ) and a SIP or SIPS URI
                (sip:caller@local_host) that indicate the originator of the request.
                This header field also has a tag parameter containing a random string
                (1928301774) that was added to the URI by the softphone.  It is used
                for identification purposes

        Call-ID: contains a globally unique identifier for this call,
                generated by the combination of a random string and the softphone's
                host name or IP address.

                    The combination of the To tag, From tag,
                    and Call-ID completely defines a peer-to-peer SIP relationship
                    between "ANY" and MITEL and is referred to as a dialog.

        CSeq:   or Command Sequence contains an integer and a method name.  The
                CSeq number is incremented for each new request within a dialog and
                is a traditional sequence number

        Contact:    contains a SIP or SIPS URI that represents a direct route to
                    contact "ANY", usually composed of a username at a fully qualified
                    domain name (FQDN).  While an FQDN is preferred, many end systems do
                    not have registered domain names, so IP addresses are permitted.

                        While the Via header field tells other elements where to send the
                        response, the Contact header field tells other elements where to send
                        future requests.


        100 Trying:

                    This response indicates that the request has been received by the
                    next-hop server and that some unspecified action is being taken on
                    behalf of this call (for example, a database is being consulted).
                    This response, like all other provisional responses, stops
                    retransmissions of an INVITE by a UAC.  The 100 (Trying) response is
                    different from other provisional responses, in that it is never
                    forwarded upstream by a stateful proxy.
        180 Ringing:

                    The UA receiving the INVITE is trying to alert the user.  This
                    response MAY be used to initiate local ringback.

        200 OK:

                    The request has succeeded.  The information returned with the
                    response depends on the method used in the request.


        486 Busy Here:

                    The callee's end system was contacted successfully, but the callee is
                    currently not willing or able to take additional calls at this end
                    system.  The response MAY indicate a better time to call in the
                    Retry-After header field.  The user could also be available

                    elsewhere, such as through a voice mail service.  Status 600 (Busy
                    Everywhere) SHOULD be used if the client knows that no other end
                    system will be able to accept this call.


    """


import asyncio
import hashlib
import io
import logging
import os
import random
import re
import select
import socket
import socketserver
import sqlite3
import ssl
import sys
import threading
import time
import timeit
import uuid
from binascii import hexlify
from datetime import datetime
# from typing import AsyncIterator

#!<--------------------------SOCKET BUFFER SIZE--------------->!
SEND_BUF_SIZE = 4096
RECV_BUF_SIZE = 4096
#!<--------------------------END------------------>!

#!<-------------------REMOTE PBX DETAILS---------->!
# REMOTE_EXT = 12000 # Variable
REMOTE_IP_MITEL = '192.168.1.250'  # '127.0.0.1'
REMOTE_PORT_MITEL = 5060 #SIP PORT
USER = 'phone'
TRANSPORT = 'UDP' # Depend on the remote pbx setting
MITEL_TGROUP = 3 # depend on the remote server settings
MITEL_CONTEXT = 'mxone-1.test.com' # context must match with remote pbx

'''
This section will work as pilot pbx system]
remote PBX will directly connect with the remote pbx system in inline method

'''
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
ANY_PILOT_PORT = 5060 # This port can be chnaged to any 
ANY_PILOT_EXT = 15000  # 15001 Take this number as Variable 
ANY_PILOT_IP = '192.168.1.115' # Where this server runining
ANY_TGROUP = 3
ANY_CONTEXT = 'ANY.test.com'
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

CONTENT_LENGHT = 0
EVENT = 'call-completion' # There are three events in this case will take one to demo
CONANYTED_PORT = 0 
DEBUG = True

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
SOCKT_TYPE  = 'ANY'
FLAP = ' '
FLAP_M = ' '
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
'''
SIP header detials as per the RFC 
need improvements 
'''
#################################################################################################
SIP = {"METHOD": ['INVITE', 'PRACK', 'ACK', 'SUBSCRIBE', 'NOTIFY', 'SIP/2.0 200 OK', 'BYE', 'OPTIONS', 'REFER'],
       "REMOTE_EXT": 'REMOTE_EXT',
       "REMOTE_IP_MITEL": REMOTE_IP_MITEL,
       "ANY_PILOT_EXT": ANY_PILOT_EXT,
       "ANY_PILOT_IP": ANY_PILOT_IP,
       "USER": USER,
       "TRANSPORT": TRANSPORT,
       "MITEL_TGROUP": MITEL_TGROUP,
       "MITEL_CONTEXT": MITEL_CONTEXT,
       "MITEL_TAG": 'MITEL_TAG',
       "MITEL_M": 'MITEL_MSG',
       "MITEL_PURPOSE": 'MITEL_PURPOSE',
       "ANY_TGROUP": ANY_TGROUP,
       "ANY_CONTEXT": ANY_CONTEXT,
       "ANY_BRANCH": 'BRANCH_ID',
       "RINSTANCE": 'REINSTANCE_NO',
       "ANY_TAG": 'ANY_TAG',
       "ANY_CALL_ID": 'ANY_CALL_ID',
       "CSEQ_NO": 'CSEQ_NO',
       "CSEQ_NOTIFY": 'NOTIFYNO',
       "RACK": 'RACK METHOD',
       "CSEQ_METHOD": ['INVITE', 'PRACK', 'ACK', 'SUBSCRIBE', 'NOTIFY', 'SIP/2.0 200 OK', 'BYE', 'OPTIONS', 'REFER'],
       "S-EXPIRES": '7200;refresher=uas',
                    "MIN_SE": '90',
                    "ALERT-INFO_A": '<urn:alert:source:internal>',
                    "ALERT-INFO_B": '<urn:alert:service:normal>',
                    "ALLOW": 'INVITE, OPTIONS, BYE, ACK, CANCEL, INFO, REGISTER, REFER,PRACK, SUBSCRIBE, NOTIFY, MESSAGE, UPDATE, PUBLISH',
                    "CONTENT_TYPE": 'application/call-completion',
                    "SUPPORTED": ['timer', 'replaces', '100rel'],
                    "USER_AGENT": 'ANYModel ANY SN/17.3.1.1.14',
                    "PRIVACY": 'none;private_none',
                    "PA_IDENTITY": '<sip:{}@{};tgrp={};trunk-context={}>'.format(ANY_PILOT_EXT, ANY_PILOT_IP, ANY_TGROUP, ANY_CONTEXT),
                    "CONTENT_LENGHT": CONTENT_LENGHT,
                    "EVENT": 'call-completion',
                    "M": ['BS', 'NR', 'NL'],
                    "SUBSCRIPTION_STATE": '{};{}'.format('terminated', 'reason=timeout'),
       }
#################################################################################################



async def debugLogging_init():
    # filename='siprfc_debug.log'
    logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
    debugInfo(f"Debug function init....{sys._getframe().f_lineno}")

def debugInfo(info):
    if DEBUG == True:
        now = datetime.now()
        date_time = now.strftime("%d-%m-%Y %H:%M:%S")
        error_ = "{}->{}".format(date_time, info)
        logging.info(error_)

'''

This function will call once the receipt of even completion msg'''
#CALLFILE CREATER AND CALLING REST API OF ANY SYSTEM  - FUNCTION BLOCK - (5):FINAL:AFTER RCV
async def SIP_RCV_READY_UPDATE(callID, cc_SATE):
    #create call file 
    #print("UPDATE MAIN DB AND CREATE CALL ACCOUNT------------")
    pass

#AFTER DATA STORED (NOTIFY SIP) IN temDIC - FUNCTION BLOCK - (4)-[2]:AFTER RCV
async def SIP_RCV_NOTIFY_DB_UPDATE(callID, cc_SATE, CSeqNo, CSeqMethod):
    try:
        conn = sqlite3.conANYt('callbackMitel.db')
        cur = conn.cursor()
    except Exception as e:
        debugInfo(f"CODE LINE:{sys._getframe().f_lineno}->{e}")
        conn.close()
        return 'F'

    try:
        # findcall_id = "SELECT * FROM callback WHERE CALLID = '{}';".format(
        #     callID)
        # cur = conn.execute(findcall_id)
        # data = cur.fetchone() 
        # if len(data) > 0:
        #     if CSeqNo != data[7]:
        #         NEXTACK = 'NX'
        #     else:
        #         NEXTACK = 'NO'

        UPDATE_call_id = "UPDATE callback SET MITELSTATUS = '{}',EESTAT = '{}', CSEQNOTIFY = '{}' WHERE CALLID='{}';".format(
            CSeqMethod, cc_SATE,CSeqNo,callID)   # "SELECT * FROM callback WHERE CALLID = '{}';".format(call_id)
        conn.execute(UPDATE_call_id)        
        
        # data = cur.fetchone()  #
        conn.commit()
        conn.close()
        debugInfo(f"ARGS RECVD: {callID}->{CSeqNo}->{CSeqMethod}->{cc_SATE}->(UPDATED TO DB) ------CODE-LINE:{sys._getframe().f_lineno}") 
        # return 'OK'
    except Exception as e:
        debugInfo(f"SIP_RCV_NOTIFY_DB_UPDATE -:CODE-LINE:{sys._getframe().f_lineno}->{e}")
    finally:
        conn.close()

#AFTER DATA STORED (NOTIFY SIP) IN temDIC - FUNCTION BLOCK - (4)-[1]:AFTER RCV
async def SIP_statusUpdate_NOTIFY(rcvList):
    #rcvList =[callID,mitelReportStatus,mitelTag,CSeqNo,CSeqMethod,cc_State,cc_Service_Retension]
    
    
    callID = rcvList[0]
    CSeqNo = rcvList[3]
    CSeqMethod = rcvList[4]
    cc_SATE = rcvList[5].lower()
    validateCC_Service = rcvList[6].lower()

    debugInfo(f"Args WHICH HOLD: {callID}->{CSeqNo}->{CSeqMethod}->{cc_SATE}->{validateCC_Service} ------CODE-LINE:{sys._getframe().f_lineno}") 

    if validateCC_Service == 'true' and cc_SATE == 'queued':
        worker200 = asyncio.create_task(
            SIP_RCV_NOTIFY_DB_UPDATE(callID, cc_SATE, CSeqNo, CSeqMethod))
        await asyncio.wait_for(worker200, timeout=None)

        
    if cc_SATE == 'ready' :
        worker200 = asyncio.create_task(
            SIP_RCV_READY_UPDATE(callID, cc_SATE))
        await asyncio.wait_for(worker200, timeout=None)

#AFTER DATA STORED (200 OK) IN temDIC - FUNCTION BLOCK - (3)-[2]:AFTER RCV
async def SIP_200_DB_UPDATE(callid,CSEqMethod,MitelTag):
    try:
        conn = sqlite3.conANYt('callbackMitel.db')
        cur = conn.cursor()
    except Exception as e:
        debugInfo(f"CODE LINE:{sys._getframe().f_lineno}->{e}")
        conn.close()
        return 'F'

    try:
        findcall_id = "UPDATE callback SET MITELSTATUS = '{}',  MITELTAG= '{}' WHERE CALLID='{}';".format(
            CSEqMethod, MitelTag,callid)   # "SELECT * FROM callback WHERE CALLID = '{}';".format(call_id)
        conn.execute(findcall_id)

               
        # data = cur.fetchone()  #
        conn.commit()
        conn.close()
        debugInfo(f"DATA WHICH HOLD: {callid}->{CSEqMethod}->{MitelTag} DB UPDATED------CODE-LINE:{sys._getframe().f_lineno}") 
        # return 'OK'
    except Exception as e:
        debugInfo(f"CODE LINE:{sys._getframe().f_lineno}->{e}")
    finally:
        conn.close()

    # pass

#AFTER DATA STORED (200 OK) IN temDIC - FUNCTION BLOCK - (3)-[1]:AFTER RCV
async def SIP_statusUpdate_200(rcvList):
    #rcvList =[callID,mitelReportStatus,mitelTag,CSeqNo,CSeqMethod]
    callID= rcvList[0]
    mitelTag =rcvList[2]
    CSeqMethod = rcvList[4]
    
    debugInfo(f"DATA WHICH HOLD IN rcvList: {rcvList} NEXT(UPDATE DB)------CODE-LINE:{sys._getframe().f_lineno}")

    worker200 = asyncio.create_task(
            SIP_200_DB_UPDATE(callID,CSeqMethod,mitelTag))
    await asyncio.wait_for(worker200, timeout=None)

#AFTER SOCKET - FUNCTION BLOCK - (2):AFTER RCV   
async def SIP_dataProcess(data, responseType):

    responseType = responseType.upper() # Always maintain the UPPER CASE to avoid confusion 

    if responseType == 'SIP/2.0 200 OK' and len(data) > 0:

        """
        {'Via': 'SIP/2.0/UDP 10.30.44.10:5060;branch=z9hG4bK-f0e9859ec-9cc5-4a489-8ad3-008768667b561;rport=41886;received=10.30.44.242', 
        'Contact': '<sip:13400@10.30.44.71:5060>', 
        'To': '<sip:13400@10.30.44.71;user=phone;transport=UDP;tgrp=1;trunk-context=mitel.test.com>;tag=40814c42', 
        'From': '<sip:15001@10.30.44.10>;user=phone;tgrp=1;trunk-context=ANY-1.test.com>;tag=9cc594ra48',
         'Call-ID': 'f0ee99859c11', 
         'CSeq': '494113 SUBSCRIBE', 'Expires': '3600', 'User-Agent': 'Aastra MX-ONE SN/17.3.1.1.14', 'Content-Length': '0'}      
        """
        # #print(data)

        callID = data['Call-ID']    # Getting CALLID 

        mitelReportStatus = '200'   # 200 Status 

        # EXAMPLE : '<sip:13400@10.30.44.71;user=phone;transport=UDP;tgrp=1;trunk-context=mitel.test.com>;tag=40814c42'
        mitelTag = (data['To'].rsplit(';', 1))[1].split('=')    # Parse the MitelCall TAG 

        if mitelTag[0] == 'tag':
            mitelTag = mitelTag[1]  # Mitel TAG DEtails 

        CSeqNo = (data['CSeq']).split(' ')[0]

        CSeqMethod = (data['CSeq']).split(' ')[1]

        rcvList = [callID, mitelReportStatus, mitelTag, CSeqNo, CSeqMethod]
        debugInfo(f"DATA WHICH HOLD IN rcvList: {rcvList} : {responseType}------CODE-LINE:{sys._getframe().f_lineno}")

        worker200 = asyncio.create_task(
            SIP_statusUpdate_200(rcvList))  # Parsing data to SIP_statusUpdate_200 

        await asyncio.wait_for(worker200, timeout=None)

    elif responseType == 'NOTIFY SIP':
        """
        {'NOTIFY sip': '15001@10.30.44.10;user=phone;transport=UDP;tgrp=1;trunk-context=ANY-1.test.com SIP/2.0', 
        'Via': 'SIP/2.0/UDP 10.30.44.71:5060;branch=z9hG4bK-524287-1---7370770d34a87951;rport', 'Max-Forwards': '70', 
        'Contact': '<sip:13400@10.30.44.71:5060>', 'To': '<sip:15001@10.30.44.10>;user=phone;tgrp=1;trunk-context=ANY-1.test.com>;tag=9cc594ra48', 
        'From': '<sip:13400@10.30.44.71;user=phone;transport=UDP;tgrp=1;trunk-context=mitel.test.com>;tag=40814c42', 'Call-ID': 'f0ee99859c11', 
        'CSeq': '3 NOTIFY', 'Content-Type': 'application/call-completion', 'User-Agent': 'Aastra MX-ONE SN/17.3.1.1.14',
         'Subscription-State': 'active;expires=3600', 
        'Event': 'call-completion', 'Content-Length': '82', 'cc-state': 'queued', 'cc-URI': 'sip:CC_20;37;transport=UDP', 'cc-service-retention': 'true'}  

    """
        callID = data['Call-ID']     # Getting CALLID 

        mitelReportStatus = 'NOTIFY'    #Manually updating NOTIFY 

        # EXAMPLE : '<sip:13400@10.30.44.71;user=phone;transport=UDP;tgrp=1;trunk-context=mitel.test.com>;tag=40814c42'
        mitelTag = (data['To'].rsplit(';', 1))[1].split('=')
        if mitelTag[0] == 'tag':
            mitelTag = mitelTag[1]
        CSeqNo = (data['CSeq']).split(' ')[0]
        CSeqMethod = (data['CSeq']).split(' ')[1]
        cc_State = data['cc-state']
        cc_Service_Retension = data['cc-service-retention']

        rcvList = [callID, mitelReportStatus, mitelTag,
                   CSeqNo, CSeqMethod, cc_State, cc_Service_Retension]

        # workerNOTIFY = asyncio.create_task(
        #     GETTING_NOTIFY_CSEQNO(callID))
        # LAST_NOTIFY_CSEQNO= await asyncio.wait_for(workerNOTIFY, timeout=None)

        
        # if CSeqNo != LAST_NOTIFY_CSEQNO:
        #     workerNOTIFY = asyncio.create_task(
        #     UPDATE_NOTIFY_CSEQNO(callID, "NEXT"))
        #     await asyncio.wait_for(workerNOTIFY, timeout=None)        
            
        debugInfo(f"DATA WHICH HOLD IN rcvList: {rcvList} : {responseType}------CODE-LINE:{sys._getframe().f_lineno}")
        workerNOTIFY = asyncio.create_task(
            SIP_statusUpdate_NOTIFY(rcvList))
        await asyncio.wait_for(workerNOTIFY, timeout=None)

    else:
        debugInfo(
            f"RCV different data from SIP_RCV_CONVERT function: {responseType}------CODE-LINE:{sys._getframe().f_lineno}")

async def ACK_LITE(conANYtion, msg):

    msg = msg.encode()
    conANYtion.sendall(msg)
    sys.stdout.flush()
    debugInfo(f"SEND ACK LITE - BYTES:->{len(msg)} Bytes -: CODE-LINE:{sys._getframe().f_lineno}")


#SOCKET RCV - FUNCTION BLOCK - (1):AFTER RCV
async def SIP_RCV_CONVERT(data,conANYtion):
    """[SIP_RCV_FUNCTION(DATA)]

    Args:
        data ([Bytes]): [Directly receive data from socket conANYtion]

    Then all the data will be transfered to data process function : SIP_dataProcess(data, responseType)
    """
    dataDecoder = data.decode() # Convert byte data to String format
    
    if len(dataDecoder) > 0:
        debugInfo(
        f"DATA RECEIVED FROM THE SOCKETS AND RCV BYTES {len(dataDecoder)}-------CODE-LINE:{sys._getframe().f_lineno}")

        temDict = {} # Temp dictionary for collecting of recv data from the SERVER 
        flag = 0    #This flag will only allow to store where contenght-length == 0
        temLine = ' '
        responseType = ''   #Initilizing of SIP Header 
        
        dataConvertIO = io.StringIO(dataDecoder) # Convert decode data to IO String

        for line in dataConvertIO:

            line = line.removesuffix('\r\n') #Removing any thing in head
            # #print(line)

            if line.find(':') > 0:  #Data seperation , based on the ':' mark 
                line = (line.split(':', 1)) #At first occurence 

                datafiled_one = line[0].strip() # Collection of Keys 
                datafiled_two = line[1].strip() # Collection of Items 

                temDict.update({datafiled_one: datafiled_two}) #    Updating Keys and Items of temDict 

                if datafiled_one == 'Content-Length' and datafiled_two == '0' and flag == 0:    # 200_handling or other response handling where content-length == 0
                    
                    worker = asyncio.create_task(
                        SIP_dataProcess(temDict, responseType)) # temDict and ResponseType parsing to the SIP_dataProcess Function
                    await asyncio.wait_for(worker, timeout=None)

                    if temLine == 'SIP/2.0 200 OK':
                        # Need to SEND ACK MESSAGE
                        ack = f"ACK {temDict['To'].rsplit(';',1)[0][1:-1]} SIP/2.0\r\n"
                        ack += f"Via:{temDict['Via']}\r\n"
                        ack += f"To:{temDict['To'].rsplit(';',1)[0]}\r\n"
                        ack += f"Call-ID:{temDict['Call-ID']}\r\n"
                        ack += f"CSeq:{random.randint(1, 100)} ACK\r\n"
                        ack += f"User-Agent:ANYModel ANY SN/17.3.1.1.14\r\n"
                        ack += f"Content-Length: 0\r\n"
                        ack += f"\r\n"
                        await asyncio.create_task(ACK_LITE(conANYtion=conANYtion, msg=ack))

                        temLine =' '

                        #print(ack)
                        temDict = {}  # reseting dictionary values to Zero

                    elif 'NOTIFY sip' in temDict:
                        ack_notify  =   f"SIP/2.0 200 OK\r\n"
                        ack_notify  +=  f"Via:{temDict['Via']}\r\n"
                        ack_notify  +=  f"Contact:{temDict['Contact']}\r\n"
                        ack_notify  +=  f"To:{temDict['To']}\r\n"
                        ack_notify  +=  f"From:{temDict['From']}\r\n"
                        ack_notify  +=  f"Call-ID:{temDict['Call-ID']}\r\n"
                        ack_notify  +=  f"CSeq:{temDict['CSeq']}\r\n"
                        ack_notify  +=  f"Subscription-State: active;expires=3600\r\n"
                        ack_notify  +=  f"User-Agent:ANYModel ANY SN/17.3.1.1.14\r\n"
                        ack_notify  +=  f"Content-Length: 0\r\n"
                        ack_notify  +=  f"\r\n"
                        debugInfo(f"GETTING NOTIFICATION MESSAGE WITH[{temDict['CSeq']}] AND RETUNNG TO REMOTE SEVER 200 OK: {line}--<{ack_notify}>----CODE-LINE:{sys._getframe().f_lineno}")
                        worker = asyncio.create_task(ACK_LITE(conANYtion=conANYtion, msg=ack_notify))#temDict and ResponseType parsing to the SIP_dataProcess Function
                        await asyncio.wait_for(worker, timeout=None)

                    elif 'SIP/2.0 100 Trying' in temDict:
                        debugInfo(f"GETTING NOTIFICATION MESSAGE WITH[{temDict}] AND RETUNNG TO REMOTE SEVER 200 OK: {line}--<{ack_notify}>----CODE-LINE:{sys._getframe().f_lineno}")
                


                        # pass 

                    #print(temDict)

                    

                elif datafiled_one == 'Content-Length' and datafiled_two != '0': #Whwere content-length != 0 will parsing data to temDict ={}
                    flag = 1    #   Not to reset temDic and continue to store data 
                    responseType = list(temDict.items())[0][0]  # Get the first temDict Key and find the Header 
                    if len(temDict)>0:
                        


                        ack_notify  =   f"SIP/2.0 200 OK\r\n"
                        ack_notify  +=  f"Via:{temDict['Via']}\r\n"
                        ack_notify  +=  f"Contact:{temDict['Contact']}\r\n"
                        ack_notify  +=  f"To:{temDict['To']}\r\n"
                        ack_notify  +=  f"From:{temDict['From']}\r\n"
                        ack_notify  +=  f"Call-ID:{temDict['Call-ID']}\r\n"
                        ack_notify  +=  f"CSeq:{temDict['CSeq']}\r\n"
                        ack_notify  +=  f"Subscription-State: active;expires=3600\r\n"
                        ack_notify  +=  f"User-Agent:ANYModel ANY SN/17.3.1.1.14\r\n"
                        ack_notify  +=  f"Content-Length: 0\r\n"
                        ack_notify  +=  f"\r\n"
                        debugInfo(f"GETTING NOTIFICATION MESSAGE AND RETUNNG TO REMOTE SEVER 200 OK: {line}--<{ack_notify}>----CODE-LINE:{sys._getframe().f_lineno}")
                
                        
                        worker = asyncio.create_task(ACK_LITE(conANYtion=conANYtion, msg=ack_notify))#temDict and ResponseType parsing to the SIP_dataProcess Function
                        await asyncio.wait_for(worker, timeout=None)
                        
                        

            else:
                line = line.strip() # Removing all None characters 
                if line == 'SIP/2.0 200 OK':    # If first Header 200 type 
                    responseType = line #Then update (This will occure on the fist SIP header)
                    temLine = line

                elif line =='SIP/2.0 100 Trying':
                    debugInfo(
                        f"RCV DIFFERENT HEADER FORMAT AWATING NEXT INSTRUCTION FROM REMOTE SERVER: {line}------CODE-LINE:{sys._getframe().f_lineno}")

                elif len(line) > 0:
                    debugInfo(
                        f"RCV DIFFERENT HEADER FORMAT NEED TO CALLBACK ANOTHER FUCNTION: {line}------CODE-LINE:{sys._getframe().f_lineno}")

        
        

        worker = asyncio.create_task(
                SIP_dataProcess(temDict, responseType)) # Parsing to SIP_dataProcess 
        await asyncio.wait_for(worker, timeout=None)

        #print(temDict)

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def CONFIRM_STATUS_HANDLER(call_id, next_status):

    # #####print(f"CONFIRM HANDLER INPUT DATA : {call_id}->{cnf}")
    try:
        conn = sqlite3.conANYt('callbackMitel.db')
        cur = conn.cursor()
    except Exception as e:
        debugInfo(f"CONFIRM HANDLER STATUS CODE-LINE:{sys._getframe().f_lineno}->{e}")
        conn.close()
        return 

    try:
        findcall_id = "UPDATE callback SET STATUS = '{}' WHERE CALLID = '{}';".format(next_status, call_id)   # "SELECT * FROM callback WHERE CALLID = '{}';".format(call_id)
        conn.execute(findcall_id)
        # data = cur.fetchone()  #
        conn.commit()
        conn.close()
        # return 'OK'
    except Exception as e:
        debugInfo(f"CODE LINE:{sys._getframe().f_lineno}->{e}")
    finally:
        conn.close()

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def GETTING_NOTIFY_CSEQNO(callID):

    try:
        conn = sqlite3.conANYt('callbackMitel.db')
        cur = conn.cursor()
    except Exception as e:
        debugInfo(f"CODE LINE:{sys._getframe().f_lineno}->{e}")
        conn.close()
        return 'F'

    try:
        findcall_id = "SELECT * FROM callback WHERE CALLID = '{}';".format(
            callID)
        cur = conn.execute(findcall_id)
        data = cur.fetchone() 

        if len(data) > 0:
            data = data[7]
          
        conn.commit()
        conn.close()
        return data 
    except Exception as e:
        debugInfo(f"CODE LINE:{sys._getframe().f_lineno}->{e}")
    finally:
        conn.close()

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def UPDATE_NOTIFY_CSEQNO(call_id, NEXTCOMMAND):
     # #####print(f"CONFIRM HANDLER INPUT DATA : {call_id}->{cnf}")
    try:
        conn = sqlite3.conANYt('callbackMitel.db')
        cur = conn.cursor()
    except Exception as e:
        debugInfo(f"UPDATE HANDLING NOTIFICATION STATUS CODE-LINE:{sys._getframe().f_lineno}->{e}")
        conn.close()
        return 

    try:
        findcall_id = "UPDATE callback SET NEXT = '{}' WHERE CALLID='{}';".format(
            NEXTCOMMAND, call_id)   # "SELECT * FROM callback WHERE CALLID = '{}';".format(call_id)
        cur = conn.execute(findcall_id)
        # data = cur.fetchone()  #
        conn.commit()
        conn.close()
        # return 'OK'
    except Exception as e:
        debugInfo(f"CODE LINE:{sys._getframe().f_lineno}->{e}")
    finally:
        conn.close()

#SOCKET SIP SEND 200 FUNCTION BLOCK - (6):DATA SND 
async def SEND_200(response):

    """[summary]

    Args:
        response ([type]): [description]

        SIP/2.0 200 OK
        Via: SIP/2.0/UDP 10.30.44.10:55964;branch=z9hG4bK-f0ec-9ccuuuuuuuuuu5-4a49-8ad3-00876866755b561;rport=55964
        Contact: <sip:10.30.44.71:5060;transport=tcp>
        To: <sip:16000@10.30.44.71;user=phone;transport=UDP;tgrp=3;trunk-context=mxone-1.test.com>;tag=672dec08
        From: <sip:15000@10.30.44.10;user=phone;tgrp=3;trunk-context=ANY.test.com>;tag=9cc594ra48
        Call-ID: 59511
        CSeq: 5 OPTIONS
        Accept: application/sdp, multipart/mixed
        Accept-Language: en
        Allow: INVITE, OPTIONS, BYE, ACK, CANCEL, INFO, REGISTER, REFER, PRACK, SUBSCRIBE, NOTIFY, MESSAGE, UPDATE, PUBLISH
        Supported: timer, replaces
        User-Agent: Aastra MX-ONE SN/17.3.1.1.14
        Allow-Events: message-summary, reg, dialog, server-side-terminal-control, call-info, line-seize, call-completion, presence
        Content-Length: 0

    """
    #response [BRANCH,CALLID,CSEQOPTIONS,ANYTAG,MITELEXT,STATUS,MITELSTATUS,CSEQACK,CSEQNOTIFY,CSEQSUB,MITELTAG,EESTAT,M,NEXTCOMMAND]
            
            
    if len(response) > 4:              
        B_ID = response[0]
        ANY_CALL_ID = response[1]
        CSEQ_NO_SUBSCRIBE = response[9]
        ANY_TAG = response[3]
        R_EXT = response[4] 
        MITEL_TAG  = response[10]
        METHOD = response[5]  
        CSEQNOTIFY = response[8]
        SUB_M   = response[12]   
        ANY_EXT = response[15]


    SIPCHANNEL_METHOD = f"SIP/2.0 200 OK\r\n"

    # SIPCHANNEL_METHODv = f"Via: SIP/2.0/UDP {SIP['REMOTE_IP_MITEL']}:5060;branch=z9hG4bK-c{SIP['ANY_BRANCH']};rport\r\n"

    SIPCHANNEL_VIA = f"Via: SIP/2.0/UDP {SIP['REMOTE_IP_MITEL']}:5060;branch=z9hG4bK-{B_ID};rport\r\n"#;={CONANYTED_PORT}

    SIPCHANNEL_MF = f"Max-Forwards: 70\r\n"

    SIPCHANNEL_CONTACT = f"Contact: <sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']}:5060>\r\n" #;transport={SIP['TRANSPORT']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>\r\n"

    # SIPCHANNEL_CONTACT  =   f"Contact: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};rinstance={SIP['RINSTANCE']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>\r\n"

    # SIPCHANNEL_TO_WITHOUT_TAG       =   f"To: <sip:{SIP['REMOTE_EXT']}@{SIP['REMOTE_IP_MITEL']}>\r\n"
    # SIPCHANNEL_TO_WITHOUT_TAG = f"To: <sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']}>\r\n"

    SIPCHANNEL_TO_WITH_TAG = f"To: <{ANY_EXT}@{SIP['ANY_PILOT_IP']}>;user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['ANY_CONTEXT']};tag={ANY_TAG}\r\n" #;tag={MITEL_TAG}

    SIPCHANNEL_FROM = f"From: <sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']};m={SUB_M}>;tag={MITEL_TAG}\r\n"
    # SIPCHANNEL_FROM     =   f"From: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};user={SIP['USER']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>;tag={SIP['ANY_TAG']}\r\n"

    SIPCHANNEL_CALLID = f"Call-ID: {ANY_CALL_ID}\r\n"

    SIPCHANNEL_CSEQ = f"CSeq: {CSEQNOTIFY} {METHOD}\r\n"

    # SIPCHANNEL_CSEQ_PRACK = f"CSeq: {SIP['CSEQ_NO']} {SIP['CSEQ_METHOD'][1]}\r\n"

    SIPCHANNEL_SE = f"Session-Expires: {SIP['S-EXPIRES']}\r\n"

    SIPCHANNEL_MSE = f"Min-SE: 90\r\n"

    SIPCHANNEL_AINFO_A = f"Alert-Info: {SIP['ALERT-INFO_A']}\r\n"

    SIPCHANNEL_AINFO_B = f"Alert-Info: {SIP['ALERT-INFO_B']}\r\n"

    SIPCHANNEL_ALLOW = f"Allow: {SIP['ALLOW']}\r\n"

    SIPCHANNEL_CT = f"Content-Type: {SIP['CONTENT_TYPE']}\r\n"

    SIPCHANNEL_SUP = f"Supported: {SIP['SUPPORTED'][0]}, {SIP['SUPPORTED'][1]}, {SIP['SUPPORTED'][2]}\r\n"

    SIPCHANNEL_UA = f"User-Agent: {SIP['USER_AGENT']}\r\n"#f"User-Agent: {SIP['USER_AGENT']}\r\n"

    SIPCHANNEL_PR = f"Privacy:{SIP['PRIVACY']}\r\n"

    SIPCHANNEL_PA = f"P-Asserted-Identity:{SIP['PA_IDENTITY']}\r\n"

    SIPCHANNEL_ACCEPT = f"Accept: application/sdp,multipart/mixe, application/simple-message-summary, message/sipfrag\r\n"

    SIPCHANNEL_EXPIRES = f"Expires: 7200\r\n"
    SIPCHANNEL_CL = f"Content-Length: 0\r\n"
    SIPCHANNEL_EVENT = f"Event: call-completion\r\n"

    SIPCHANNEL_EOL = f"\r\n"


    NOTIFY200OK__MSG = SIPCHANNEL_METHOD + SIPCHANNEL_VIA +   \
        SIPCHANNEL_CONTACT +    \
        SIPCHANNEL_TO_WITH_TAG + SIPCHANNEL_FROM +   \
        SIPCHANNEL_CALLID + SIPCHANNEL_CSEQ +   \
        SIPCHANNEL_EXPIRES+ SIPCHANNEL_UA  + \
        SIPCHANNEL_CL + SIPCHANNEL_EOL

    debugInfo(f"SENDING 200 OK MESSAGE TO MITL SERVER -: {SIPCHANNEL_METHOD}")
    #print(NOTIFY200OK__MSG)
    return NOTIFY200OK__MSG


    
    pass

#SOCKET SEND SIP SUBSCRIBE FUNCTION BLOCK - (5):DATA SND
async def SIP_SUBSCRIBE(response):

    #response [BRANCH,CALLID,CSEQOPTIONS,ANYTAG,MITELEXT,STATUS,MITELSTATUS,CSEQACK,CSEQNOTIFY,CSEQSUB,MITELTAG,EESTAT,M]
    if len(response) > 4:              
        B_ID = response[0]
        ANY_CALL_ID = response[1]
        CSEQ_NO_SUBSCRIBE = response[9]
        ANY_TAG = response[3]
        R_EXT = response[4] 
        MITEL_TAG  = response[10]
        METHOD = response[6]  
        SUB_M   = response[12]  
        ANY_EXT = response[15]      

        #removed from all : ;user={SIP['USER']}



    SIPCHANNEL_METHOD = f"{SIP['METHOD'][3]} sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']};m={SUB_M} SIP/2.0\r\n"

    # SIPCHANNEL_METHODv = f"Via: SIP/2.0/UDP {SIP['REMOTE_IP_MITEL']}:5060;branch=z9hG4bK-c{SIP['ANY_BRANCH']};rport\r\n"

    SIPCHANNEL_VIA = f"Via: SIP/2.0/UDP {SIP['ANY_PILOT_IP']}:{CONANYTED_PORT};branch=z9hG4bK-{B_ID};rport\r\n"

    SIPCHANNEL_MF = f"Max-Forwards: 70\r\n"

    SIPCHANNEL_CONTACT = f"Contact: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>\r\n"

    # SIPCHANNEL_CONTACT  =   f"Contact: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};rinstance={SIP['RINSTANCE']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>\r\n"

    # SIPCHANNEL_TO_WITHOUT_TAG       =   f"To: <sip:{SIP['REMOTE_EXT']}@{SIP['REMOTE_IP_MITEL']}>\r\n"
    SIPCHANNEL_TO_WITHOUT_TAG = f"To: <sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']}>\r\n"

    SIPCHANNEL_TO_WITH_TAG = f"To: <sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']};m={SUB_M}>\r\n" #;tag={MITEL_TAG}

    SIPCHANNEL_FROM = f"From: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']}>;user={SIP['USER']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']};tag={ANY_TAG}\r\n"
    # SIPCHANNEL_FROM     =   f"From: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};user={SIP['USER']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>;tag={SIP['ANY_TAG']}\r\n"

    SIPCHANNEL_CALLID = f"Call-ID: {ANY_CALL_ID}\r\n"

    SIPCHANNEL_CSEQ = f"CSeq: {CSEQ_NO_SUBSCRIBE} {SIP['CSEQ_METHOD'][3]}\r\n"

    # SIPCHANNEL_CSEQ_PRACK = f"CSeq: {SIP['CSEQ_NO']} {SIP['CSEQ_METHOD'][1]}\r\n"

    SIPCHANNEL_SE = f"Session-Expires: {SIP['S-EXPIRES']}\r\n"

    SIPCHANNEL_MSE = f"Min-SE: 90\r\n"

    SIPCHANNEL_AINFO_A = f"Alert-Info: {SIP['ALERT-INFO_A']}\r\n"

    SIPCHANNEL_AINFO_B = f"Alert-Info: {SIP['ALERT-INFO_B']}\r\n"

    SIPCHANNEL_ALLOW = f"Allow: {SIP['ALLOW']}\r\n"

    SIPCHANNEL_CT = f"Content-Type: {SIP['CONTENT_TYPE']}\r\n"

    SIPCHANNEL_SUP = f"Supported: {SIP['SUPPORTED'][0]}, {SIP['SUPPORTED'][1]}, {SIP['SUPPORTED'][2]}\r\n"

    SIPCHANNEL_UA = f"User-Agent: {SIP['USER_AGENT']}\r\n"

    SIPCHANNEL_PR = f"Privacy:{SIP['PRIVACY']}\r\n"

    SIPCHANNEL_PA = f"P-Asserted-Identity:{SIP['PA_IDENTITY']}\r\n"

    SIPCHANNEL_ACCEPT = f"Accept: application/sdp,multipart/mixe, application/simple-message-summary, message/sipfrag\r\n"

    SIPCHANNEL_CL = f"Content-Length: 0\r\n"

    SIPCHANNEL_EVENT = f"Event: call-completion\r\n"

    SIPCHANNEL_EOL = f"\r\n"


    SUBCRIBE_MSG = SIPCHANNEL_METHOD + SIPCHANNEL_VIA +   \
        SIPCHANNEL_MF + SIPCHANNEL_CONTACT +    \
        SIPCHANNEL_TO_WITH_TAG + SIPCHANNEL_FROM +   \
        SIPCHANNEL_CALLID + SIPCHANNEL_CSEQ +   \
        SIPCHANNEL_SE +   \
        SIPCHANNEL_ALLOW + SIPCHANNEL_SUP + \
        SIPCHANNEL_UA + SIPCHANNEL_EVENT + \
        SIPCHANNEL_CL + SIPCHANNEL_EOL

    debugInfo(f"SUBSCRIBE COMPLETED - {SIPCHANNEL_METHOD}")
    # #####print(SUBCRIBE_MSG)
    return SUBCRIBE_MSG

#NEED UPDATE FOR THIS 
async def SEND_SUBSCRIBE(response_sub):
    #response [BRANCH,CALLID,CSEQOPTIONS,ANYTAG,MITELEXT,STATUS,MITELSTATUS,CSEQACK,CSEQNOTIFY,CSEQSUB,MITELTAG,EESTAT,M]
    pass

#SOCKET SEND SIP ACK FUNCTION BLOCK - (4):DATA SND
async def SIP_ACK(response_db):

    #response [BRANCH,CALLID,CSEQOPTIONS,ANYTAG,MITELEXT,STATUS,MITELSTATUS,CSEQACK,CSEQNOTIFY,CSEQSUB,MITELTAG,EESTAT,M]

    if len(response_db) > 4:      
        
        B_ID = response_db[0]
        ANY_CALL_ID = response_db[1]
        # CSEQ_NO_OPTIONS = response_db[2]
        ANY_TAG = response_db[3]
        R_EXT = response_db[4] 
        MITEL_TAG  = response_db[10]
        METHOD = response_db[6]   
        ANY_EXT = response_db[15]
        

        # if METHOD == 'OPTIONS':
        CSEQ_NO_METHOD = random.randint(1, 100)
        METHOD = 'ACK'
        # #print(METHOD)
        # #print(response_db)
        # sys.exit(0)
        # elif METHOD == 'SUB':
        #     CSEQ_NO_METHOD = result[8]
        # elif METHOD == 'NOTIFY':
        #     CSEQ_NO_METHOD = result[7]
        # elif METHOD == 'ACK':
        #     CSEQ_NO_METHOD = random.randint(1, 100000)
            # taskACK = asyncio.create_task(db_ACK_HANDLER(CALLER_ID,CSEQ_NO_METHOD))
            # await asyncio.wait_for(taskACK,timeout=None)

        # ANY_TAG = result[10]
        # MITEL_TAG = result[11]
        # SUB_M = result[13]  # CALL_BOOKING
        # R_EXT = result[17]  # REMOTE EXTENTION

    # SIPCHANNEL_METHOD = f"{SIP['METHOD'][4]} sip:{SIP['REMOTE_EXT']}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']} SIP/2.0\r\n"



    SIPCHANNEL_METHOD = f"{SIP['METHOD'][2]} sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']} SIP/2.0\r\n"

    # SIPCHANNEL_METHODv = f"Via: SIP/2.0/UDP {SIP['REMOTE_IP_MITEL']}:5060;branch=z9hG4bK-c{SIP['ANY_BRANCH']};rport\r\n"

    SIPCHANNEL_VIA = f"Via: SIP/2.0/UDP {SIP['ANY_PILOT_IP']}:{CONANYTED_PORT};branch=z9hG4bK-{B_ID};rport\r\n"

    SIPCHANNEL_MF = f"Max-Forwards: 70\r\n"

    SIPCHANNEL_CONTACT = f"Contact: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>\r\n"

    # SIPCHANNEL_CONTACT  =   f"Contact: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};rinstance={SIP['RINSTANCE']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>\r\n"

    # SIPCHANNEL_TO_WITHOUT_TAG       =   f"To: <sip:{SIP['REMOTE_EXT']}@{SIP['REMOTE_IP_MITEL']}>\r\n"
    SIPCHANNEL_TO_WITHOUT_TAG = f"To: <sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']}>\r\n"

    SIPCHANNEL_TO_WITH_TAG = f"To: <sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']}>\r\n" #;tag={MITEL_TAG}

    SIPCHANNEL_FROM = f"From: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};user={SIP['USER']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>;tag={ANY_TAG}\r\n"
    # SIPCHANNEL_FROM     =   f"From: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};user={SIP['USER']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>;tag={SIP['ANY_TAG']}\r\n"

    SIPCHANNEL_CALLID = f"Call-ID: {ANY_CALL_ID}\r\n"

    SIPCHANNEL_CSEQ =f"CSeq: {CSEQ_NO_METHOD} {METHOD}\r\n"

    # SIPCHANNEL_CSEQ_PRACK = f"CSeq: {SIP['CSEQ_NO']} {SIP['CSEQ_METHOD'][1]}\r\n"

    SIPCHANNEL_SE = f"Session-Expires: {SIP['S-EXPIRES']}\r\n"

    SIPCHANNEL_MSE = f"Min-SE: 90\r\n"

    SIPCHANNEL_AINFO_A = f"Alert-Info: {SIP['ALERT-INFO_A']}\r\n"

    SIPCHANNEL_AINFO_B = f"Alert-Info: {SIP['ALERT-INFO_B']}\r\n"

    SIPCHANNEL_ALLOW = f"Allow: {SIP['ALLOW']}\r\n"

    SIPCHANNEL_CT = f"Content-Type: {SIP['CONTENT_TYPE']}\r\n"

    SIPCHANNEL_SUP = f"Supported: {SIP['SUPPORTED'][0]}, {SIP['SUPPORTED'][1]}, {SIP['SUPPORTED'][2]}\r\n"

    SIPCHANNEL_UA = f"User-Agent: {SIP['USER_AGENT']}\r\n"

    SIPCHANNEL_PR = f"Privacy:{SIP['PRIVACY']}\r\n"

    SIPCHANNEL_PA = f"P-Asserted-Identity:{SIP['PA_IDENTITY']}\r\n"

    SIPCHANNEL_ACCEPT = f"Accept: application/sdp,multipart/mixe, application/simple-message-summary, message/sipfrag\r\n"

    SIPCHANNEL_CL = f"Content-Length: 0\r\n"

    SIPCHANNEL_EOL = f"\r\n"

    NOTIFY_ACK_MSG = SIPCHANNEL_METHOD + SIPCHANNEL_VIA + SIPCHANNEL_TO_WITH_TAG + SIPCHANNEL_FROM +   \
        SIPCHANNEL_CALLID + SIPCHANNEL_CSEQ + SIPCHANNEL_UA +\
        SIPCHANNEL_CL + SIPCHANNEL_EOL
    debugInfo(f"NOTIFY ACK COMPLETED - {SIPCHANNEL_METHOD}")
    # SQLITEUPDATECSEQ('NOTIFY', SIP['CSEQ_NOTIFY'])
    # #print(NOTIFY_ACK_MSG)


    # sys.exit(0)
    return NOTIFY_ACK_MSG

#SOCKET SEND SIP OPTIONS FUNCTION BLOCK - (3):DATA SND
async def SIP_OPTION(response_db):
    #[BRANCHID,CALLID,CSEQNO_OPTION,ANYTAG,REMOTE_EXTENSION]
    if len(response_db) > 4:

        B_ID = response_db[0]
        ANY_CALL_ID = response_db[1]
        CSEQ_NO_OPTIONS = response_db[2]
        ANY_TAG = response_db[3]
        R_EXT = response_db[4]       
        ANY_EXT = response_db[15]
        
        
    # ######print(result)

    SIPCHANNEL_METHOD = f"{SIP['METHOD'][7]} sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']} SIP/2.0\r\n"

    # SIPCHANNEL_METHODv = f"Via: SIP/2.0/UDP {SIP['REMOTE_IP_MITEL']}:5060;branch=z9hG4bK-c{SIP['ANY_BRANCH']};rport\r\n"

    SIPCHANNEL_VIA = f"Via: SIP/2.0/UDP {SIP['ANY_PILOT_IP']}:{CONANYTED_PORT};branch=z9hG4bK-{B_ID};rport\r\n"

    SIPCHANNEL_MF = f"Max-Forwards: 70\r\n"

    SIPCHANNEL_CONTACT = f"Contact: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>\r\n"

    # SIPCHANNEL_CONTACT  =   f"Contact: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};rinstance={SIP['RINSTANCE']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>\r\n"

    # SIPCHANNEL_TO_WITHOUT_TAG       =   f"To: <sip:{SIP['REMOTE_EXT']}@{SIP['REMOTE_IP_MITEL']}>\r\n"
    SIPCHANNEL_TO_WITHOUT_TAG = f"To: <sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']}>\r\n"

    SIPCHANNEL_TO_WITH_TAG = f"To: <sip:{R_EXT}@{SIP['REMOTE_IP_MITEL']};user={SIP['USER']};transport={SIP['TRANSPORT']};tgrp={SIP['MITEL_TGROUP']};trunk-context={SIP['MITEL_CONTEXT']}>;tag={SIP['MITEL_TAG']}\r\n"

    SIPCHANNEL_FROM = f"From: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};user={SIP['USER']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>;tag={ANY_TAG}\r\n"
    # SIPCHANNEL_FROM     =   f"From: <sip:{ANY_EXT}@{SIP['ANY_PILOT_IP']};user={SIP['USER']};tgrp={SIP['ANY_TGROUP']};trunk-context={SIP['ANY_CONTEXT']}>;tag={SIP['ANY_TAG']}\r\n"

    SIPCHANNEL_CALLID = f"Call-ID: {ANY_CALL_ID}\r\n"

    SIPCHANNEL_CSEQ = f"CSeq: {CSEQ_NO_OPTIONS} {SIP['CSEQ_METHOD'][7]}\r\n"

    # SIPCHANNEL_CSEQ_PRACK = f"CSeq: {SIP['CSEQ_NO']} {SIP['CSEQ_METHOD'][1]}\r\n"

    SIPCHANNEL_SE = f"Session-Expires: {SIP['S-EXPIRES']}\r\n"

    SIPCHANNEL_MSE = f"Min-SE: 3600\r\n"

    SIPCHANNEL_AINFO_A = f"Alert-Info: {SIP['ALERT-INFO_A']}\r\n"

    SIPCHANNEL_AINFO_B = f"Alert-Info: {SIP['ALERT-INFO_B']}\r\n"

    SIPCHANNEL_ALLOW = f"Allow: {SIP['ALLOW']}\r\n"

    SIPCHANNEL_CT = f"Content-Type: {SIP['CONTENT_TYPE']}\r\n"

    SIPCHANNEL_SUP = f"Supported: {SIP['SUPPORTED'][0]}, {SIP['SUPPORTED'][1]}, {SIP['SUPPORTED'][2]}\r\n"

    SIPCHANNEL_UA = f"User-Agent: {SIP['USER_AGENT']}\r\n"

    SIPCHANNEL_PR = f"Privacy:{SIP['PRIVACY']}\r\n"

    SIPCHANNEL_PA = f"P-Asserted-Identity:{SIP['PA_IDENTITY']}\r\n"

    SIPCHANNEL_ACCEPT = f"Accept: application/sdp,multipart/mixe, application/simple-message-summary, message/sipfrag\r\n"

    SIPCHANNEL_CL = f"Content-Length: 0\r\n"

    SIPCHANNEL_EOL = f"\r\n"

    OPTION_MSG = SIPCHANNEL_METHOD + SIPCHANNEL_VIA +   \
        SIPCHANNEL_MF + SIPCHANNEL_CONTACT +    \
        SIPCHANNEL_TO_WITHOUT_TAG + SIPCHANNEL_FROM +   \
        SIPCHANNEL_CALLID + SIPCHANNEL_CSEQ +   \
        SIPCHANNEL_SE + SIPCHANNEL_MSE +    \
        SIPCHANNEL_AINFO_A + SIPCHANNEL_AINFO_B +   \
        SIPCHANNEL_ALLOW + SIPCHANNEL_SUP + \
        SIPCHANNEL_UA + SIPCHANNEL_PR + SIPCHANNEL_ACCEPT + \
        SIPCHANNEL_PA + SIPCHANNEL_CL + SIPCHANNEL_EOL

    debugInfo(f"INVITE COMPLETED - {SIPCHANNEL_METHOD}")

    #print(OPTION_MSG)

    return OPTION_MSG

#SOCKET SEND FUNCTION BLOCK - (2):DATA SND (ALL LOGICS - FOR SELECTING SIP-HEADERS)-ALL LOGIC DECISIONS 
async def SIP_SIGNAL_SENDING(conANYtion,response):
    global FLAP , FLAP_M

    #[BRANCHID,CALLID,CSEQNO_OPTION,ANYTAG,REMOTE_EXTENSION]

    CALLER_ID   =    response[1]
    # #print(response)

    if FLAP != response[5]:
        debugInfo(f"RCVD DATA FOR SIP-SIGNA-FUNCTION [STATUS]->{response} -: CODE-LINE:{sys._getframe().f_lineno}")
        FLAP = response[5]

    if FLAP_M != response[6]:
        debugInfo(f"RCVD DATA FOR SIP-SIGNA-FUNCTION [MITEL-STATUS]->{response} -: CODE-LINE:{sys._getframe().f_lineno}")
        FLAP_M = response[6]

    
    if response[5] == 'RQ'  and response[6] == 'None':
        print(response)        
        worker = asyncio.create_task(
            SIP_OPTION(response))
        result = await asyncio.wait_for(worker, timeout=None)
        try:
            msg = result.encode()
            conANYtion.sendall(msg)
            sys.stdout.flush()
            debugInfo(f"SEND SIP OPTIONS MSG BYTES:  ->{len(msg)} -: CODE-LINE:{sys._getframe().f_lineno}")
            # #print(msg)
            # sys.exit(0)
            complete = asyncio.create_task(
                CONFIRM_STATUS_HANDLER(CALLER_ID, 'OP'))
            await asyncio.wait_for(complete, timeout=None)
            debugInfo(f"UPDATED DATABASE [STATUS]:  -> *OP* -: CODE-LINE:{sys._getframe().f_lineno}")

        except Exception as e:
            debugInfo(f"SIP_SEND_HANDLER FUNCTION ERROR HAS BEEN RAISED DUE -: CODE-LINE:{sys._getframe().f_lineno}->{e}")
    
    elif response[5] == 'OP'  and response[6] == 'OPTIONS': # response[6] is based on rcvd CSEQ method [CSEQNO : 1 OPTIONS] 
        #Send ACK NOW 
        # #print(response)
        # sys.exit(0)
        #     worker = asyncio.create_task(
        #         SIP_ACK(response))
        #     result = await asyncio.wait_for(worker, timeout=None)
            
        # # try:
        #     msg = result.encode()
        #     conANYtion.sendall(msg)
        #     # conANYtion.sendall(msg)
        #     sys.stdout.flush()
        #     debugInfo(f"SEND SIP ACK AFTER THE 200 RESPONSE AND SENT BYTES:  ->{len(msg)} -: CODE-LINE:{sys._getframe().f_lineno}")
            # sys.exit(0)
            complete = asyncio.create_task(
                CONFIRM_STATUS_HANDLER(CALLER_ID, 'ACK'))
            await asyncio.wait_for(complete, timeout=None)
            # sys.exit(0)
            # await asyncio.sleep(0.2)
            debugInfo(f"UPDATED DATABASE [STATUS]:  -> *ACK* -: CODE-LINE:{sys._getframe().f_lineno}")

        # except Exception as e:
        #     debugInfo(f"SIP_SEND_HANDLER FUNCTION ERROR HAS BEEN RAISED DUE -: CODE-LINE:{sys._getframe().f_lineno}->{e}")
        # pass

    elif response[5] == 'ACK':
        #Send ACK NOW 
        # #print(response)
        # sys.exit(0)
            worker = asyncio.create_task(
                SIP_SUBSCRIBE(response))
            result = await asyncio.wait_for(worker, timeout=None)
            # #print(result)
        # try:
            msg = result.encode()
            conANYtion.sendall(msg)
            sys.stdout.flush()
            debugInfo(f"SEND SIP SUBSCRIBE AFTER THE *ACK* AND SENT BYTES:  ->{len(msg)} -: CODE-LINE:{sys._getframe().f_lineno}")
            # #print(msg)
            # sys.exit(0)
            complete = asyncio.create_task(
                CONFIRM_STATUS_HANDLER(CALLER_ID, 'NOTIFY'))
            await asyncio.wait_for(complete, timeout=None)

            complete = asyncio.create_task(
                    UPDATE_NOTIFY_CSEQNO(CALLER_ID, 'QUE'))
            await asyncio.wait_for(complete, timeout=None)
            debugInfo(f"UPDATED DATABASE [STATUS]:  -> *NOTIFY* -: CODE-LINE:{sys._getframe().f_lineno}")

        # # except Exception as e:
        #     debugInfo(f"SIP_SEND_HANDLER FUNCTION ERROR HAS BEEN RAISED DUE -: CODE-LINE:{sys._getframe().f_lineno}->{e}")
        # pass

    elif response[5] == 'NOTIFY'  and response[6] == 'NOTIFY':
        #['f0ec-9ccuuuuuuuuuu5-4a49-8ad3-00876866755b561', '59511', '5', '9cc594ra48', '16000', 'NOTIFY', 'NOTIFY', '78864', '3', '444', 'c8a4eb3f', 'queued', 'NR',NEXTCOMMAND]
        # #print(response)
        if  response[14] =='NEXT':
            # #print(response)
            # #print("Sysytem EXIT AFTER BOTH NOTIFY OPTION")
            # worker = asyncio.create_task(
            #         SEND_200(response))
            # result = await asyncio.wait_for(worker, timeout=None)
            #     # #print(result)
            # # try:
            # msg = result.encode()
            # conANYtion.sendall(msg)
            #     # conANYtion.sendall(msg)
            # sys.stdout.flush()
            # #print(msg)
            # #     # sys.exit(0)
            complete = asyncio.create_task(
                    UPDATE_NOTIFY_CSEQNO(CALLER_ID, 'UP'))
            await asyncio.wait_for(complete, timeout=None)
                # sys.exit(0)
            await asyncio.sleep(0.2)
            debugInfo(f"ACK MESSAGE SEND AFTER RECEVING 200 Message IN CASE OF TRANSITE PBX -: CODE-LINE:{sys._getframe().f_lineno}")
       
        # elif response[11] == 'ready' :
        #     #Create Call file and delete the data base 
        #     pass
        elif  response[14] =='QUE':
            # worker = asyncio.create_task(
            #         SIP_ACK(response))
            # result = await asyncio.wait_for(worker, timeout=None)
            #     # #print(result)
            # # try:
            # msg = result.encode()
            # conANYtion.sendall(msg)
            #     # conANYtion.sendall(msg)
            # sys.stdout.flush()
            # #print(msg)
            # #     # sys.exit(0)
            complete = asyncio.create_task(
                    UPDATE_NOTIFY_CSEQNO(CALLER_ID, 'NEXT'))
            await asyncio.wait_for(complete, timeout=None)
                # sys.exit(0)
            # await asyncio.sleep(0.2)
            debugInfo(f"ACK MESSAGE SEND AFTER RECEVING 200 Message IN CASE OF TRANSITE PBX -: CODE-LINE:{sys._getframe().f_lineno}")
            # sys.exit(0)

#SOCKET SEND FUNCTION BLOCK - (1):DATA SND
async def SOCKET_SEND(conANYtion):
    """[SOCKET_SEND]

    
    Args:
        conANYtion ([socket]): [socket instance for sending data to mitel Intier server]
        respose ([sqlite3]): [this will return the list of data [call-id,status,prime-id]]

        * Depend on the response - status following switching function 

        #response    ;   [CALLID, STATUS,PRIME-ID,MITEL_STATUS,CSEQNOTIFY,EESTAT]

        response[1] == 'RQ'
            * This status where initial request send by the caller where sending requesting callee by DTMF  pressing 6
                Then Server will send OPTIONS SIP command to conANYtion socket to send data to Mitel Server  
            
                    Function:   SEND_OPTIONS_HANDLER(respose[0])) 
                    Arg     :   response[0] -> call-Id from database 
                    return  :   SIP OPTIONS Message 
        response[1] == '200'

            When status become a 200, that means the mitel server is responding by accepting OPTIONS request
                Then 200 status updated by the RCV_HANDLER() function 
                Functions   :   SEND_ACK_HANDLER(CSLL-ID, ACK_METHOD)
                args        :   CALL-ID and ACK_METHOD 
                return      :   ACK message will return from this function and it will send through instance conANYtion socket to the Mitel Server

                    * Then STATUS will be updated as 'SU' , that mean awating to send SUBSCRIBE message to Mitel Sever through the function of  

                        Function    :   CONFIRM_HANDLER(respose[0], 'WAIT')

                            * Status will be updated as WAIT 
                                * This means , ANY callback server will stay untill reception of first NOTIFY command 
        
        * Soon after receving the NOTIFY message status 
            * system will identify the CC_STATUS and it will update the database system 
                * if CC_STATUS == QUEUE 
                    * then ACK_NOTIFY message will send Mitel Server  with NOTIFY message CSEQ: CSEQ_NOTIFY_NO NOTIFY 

                        *
                ***EVERY NOTIFY MESSAGE ACK_NOTIFY WILL SEND 
                    *** Once the CC_STATUS == READY 
                        THEN NEED TO SEND ***** ACK_NOTIFY MESSAGE 
                            *** Canceal message will be sent if it is required 

    """

    try:
        conn = sqlite3.conANYt('callbackMitel.db')
        cur = conn.cursor()
    except Exception as e:
        debugInfo(
        f"DATABASE ACCESS ERROR  --{conn}-----CODE-LINE:{sys._getframe().f_lineno}")
        conn.close()
        return        

    try:
        qCommand= "SELECT * FROM callback;"
        cur.execute(qCommand)
        dataFetch = cur.fetchall()
        # #print(dataFetch)
        # #print(data)
        # sys.exit(0)
        # data = cur.fetchone()
        for data in dataFetch:
        # if len(data)>0:
            # #print(data)
            # sys.exit(0)
            #MAIN FUNCTION TO BE ADDAD 
            #[BRANCHID,CALLID,CSEQNO_OPTION,ANYTAG,REMOTE_EXTENSION]
            #ID,branch, callid,cseqOption,cseqInvite,

            """    

            
            [DATABASE ROWS]

            0   `ID`	INTEGER NOT NULL,
            1   `BRANCH`	TEXT,
            2   `CALLID`	TEXT,
            3   `CSEQOPTIONS`	TEXT,
            4   `CSEQINVITE`	TEXT,
            5   `CSEQPRACK`	TEXT,
            6   `CSEQACK`	TEXT,
            7   `CSEQNOTIFY`	TEXT,
            8   `CSEQSUB`	TEXT,
            9  `RINSTANCE`	TEXT,
            10  `ANYTAG`	TEXT,
            11  `MITELTAG`	TEXT,
            12  `PURPOSE`	TEXT,
            13  `M`	TEXT,
            14  `TIMESTAMPSTART`	TEXT,
            15  `TIMESTAMPUPDATE`	TEXT,
            16  `TIMESTAMPEND`	TEXT,
            17  `MITELEXT`	TEXT,
            18  `ANYEXT`	TEXT,
            19  `EESTAT`	TEXT,
            20  `STATUS`	TEXT,
            21  `MITELSTATUS`	TEXT,
            22  `NOTIFYUPDATE`	TEXT,
            23  `NEXT`	TEXT,
            
            """
            #response [BRANCH,CALLID,CSEQOPTIONS,ANYTAG,MITELEXT,STATUS,MITELSTATUS,CSEQACK,CSEQNOTIFY,CSEQSUB,MITELTAG,EESTAT,M,NEXTCOMMAND]
            response = [data[1],data[2],data[3],data[10],data[17],data[20],data[21],data[6],data[7],data[8],data[11],data[19],data[13],data[22],data[23],data[18]]
            # #print(response)
            # sys.exit(0)
            worker = asyncio.create_task(
            SIP_SIGNAL_SENDING(conANYtion, response))   #   Where data presence system will parss all the data 
            await asyncio.wait_for(worker, timeout=None)
            await asyncio.sleep(0.1)
            
        conn.close()
    except Exception as e:
        debugInfo(
        f"DATABASE ACCESS ERROR in fetching instance -{e} ------CODE LINE:{sys._getframe().f_lineno}")
    finally:
        conn.close()

#MAIN SOCKET FUNCTION BLOCK - (0)
async def SOCKETCONANYTION():
    global CONANYTED_PORT

    pid = os.fork()

    debugInfo(
        f"SOCKET UDP CONANYTION ESTABILISHING ---SOCKET-IPPROTO{SOCKT_TYPE}----CODE LINE:{sys._getframe().f_lineno}->SOCKET CONANYTION STARTED")
    # try:

    if SOCKT_TYPE == 'ANY':

        conANYtion = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
        conANYtion.settimeout(180)
        conANYtion.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        conANYtion.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1) 
        conANYtion.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, SEND_BUF_SIZE)
        conANYtion.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, RECV_BUF_SIZE)


    elif SOCKT_TYPE == 'MITEL':
        
        conANYtion = socket.socket(
            socket.AF_INET, socket.SOCK_DGRAM,socket.IPPROTO_UDP)  # Creating Socket        
        conANYtion.settimeout(180)      #Wait standard ringing time Need to find best values        
        conANYtion.setblocking(False)
        conANYtion.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        
        conANYtion.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, SEND_BUF_SIZE)
        conANYtion.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, RECV_BUF_SIZE)       

    debugInfo(
        f"SOCKET-CONANYTION CREATED WITHOUT ERRORS-------CODE-LINE:{sys._getframe().f_lineno}->SOCKET CONANYTION TRYING")
    try:
        
        conANYtion.conANYt((REMOTE_IP_MITEL, REMOTE_PORT_MITEL))# ConANYting to the Sever

        CONANYTED_PORT = int(str(conANYtion).split()[6].split(')')[0])
        #print(f"CONANYTED TO MITEL SERVER THROUGH  ORT NO : {CONANYTED_PORT}")

        # conANYtion.
    except Exception as e:

        debugInfo(
            f"This Exception is while estabilishing conANYtion between 'server' [{sys._getframe().f_lineno}]->{e}CHECK THE ROUTER")

    debugInfo(f"ConANYtion information -:[{sys._getframe().f_lineno}]->{conANYtion}")

    # start = timeit.default_timer()


    while True:
        readers, xw, xr = select.select([sys.stdin, conANYtion], [], [])    # This selector will manage the readers TX and Rx availability
        
        for r in readers:   # While ConANYtion mode -> Selector will allow send data to Server            
            # if os.fork()> 0:
            if pid > 0:

                if r is conANYtion:
                
                    """
                    RCV_HANDLER(RECEIVED DATA)
                    Function Name   : RCV_HANDLER
                    args            : Receving data from Mitel Server
                    Buffer Size     : SEND_BUF_SIZE
                    Parsing Data    : data (Byte Mode)
                    return          : NO
                    Parsing function to Asynic mode in order to operate the main function in mode of damean 
                    """
                    data = conANYtion.recv(SEND_BUF_SIZE)
                    if len(data)>0:
                        #print(data)
                        worker = asyncio.create_task(SIP_RCV_CONVERT(data,conANYtion))
                        await asyncio.wait_for(worker, timeout=None)
                else:              
                    
                    """
                    SIP_SEND_QUEUE()
                    Function Name   : SIP_SEND_QUEUE
                    args            : no args only function will callback the next setup 


                    return          : response ['call-id', status,prime-id]

                    @@@@@@@@@@@@******Need improment in order to send many messages to the server 

                    **
                        response length always to be more than the 1
                        in order to callback the SOCKET_SEND(arg1,arg2,arg3)

                        SOCKET_SEND(conANYtion=conANYtion, respose=respose)

                        args    :   conANYtion[socket]
                                    response[from callbackMitel.db]
                        return  : no 
                    """
                    # if (timeit.default_timer() - start )> 10:

                    worker = asyncio.create_task(SOCKET_SEND(conANYtion=conANYtion))    #   DATA WILL SEND TO THE SOCKET 
                    await asyncio.wait_for(worker, timeout=None)
                    # print(timeit.default_timer() - start)

                        # start = timeit.default_timer()
            # else:
            #     print("SYSTEM NOT ALLOW TO TX RX_>>>>>>>>")
    # except Exception as e:
    #     debugInfo(f"RUN SOCKET FUNCTION [CODE LINE] -:{sys._getframe().f_lineno}->{e}")
    # finally:
    #     conANYtion.close()

async def run():
    await asyncio.create_task(debugLogging_init())
    await asyncio.gather(SOCKETCONANYTION())

if __name__ == '__main__':
    asyncio.run(run(), debug=False)
    # run()
